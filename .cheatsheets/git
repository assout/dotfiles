# add - ステージングする
git add -i # ファイルごとに対話的に選択する
git add -p # 部分的に追加する Refs. [Gitで部分的にコミットする方法 - Qiita](http://qiita.com/miyohide/items/79ab0ff3b3852289a6be)
git add -u # 変更のみ追加する(新規追加はしない) Refs: [git add -A と git add . と git add -u の違い - nekovaの日記](http://nekova.hatenablog.com/entry/2013/02/20/013909)
git add -f # 無視されるファイルを強制的にインデックスに追加する

# commit - コミットする
git commit -m "commit reason"                     # 簡易コメントでコミット
git commit -m "commit reason" -m "seconds reason" # 簡易コメントでコミット
git commit -a                                     # 作業ツリーの変更をすべてコミットする
git commit somefile                               # ファイルを指定してコミット
git commit -m "hoge" -a                           # コミット内容を訂正
git commit --amend -a                             # 修正しステージング
git commit --amend -m "comment"                   # コミットコメントを修正(amend)
git commit -v                                     # 詳細(diff)を表示してコミット
git commit -c HEAD                                # 以前のコミットメッセージを利用する
git commit -c HEAD^                               # 以前のコミットメッセージを利用する

# diff - 差分を見る
git diff                                 # 作業ツリーとステージングエリア間
git diff --cached                        # ステージングエリアとリポジトリ間
git diff HEAD                            # 作業ツリーとリポジトリ間
git diff origin (リモート設定名による？) # ローカルブランチとリモートブランチの間
git diff <revision>                      # バージョン間の差分を見る
git diff HEAD^                           # バージョン間の差分を見る
git diff *main*                          # パス指定

# branch, checkout - ブランチを操作する
git branch new-feature                         # ブランチを作成する
git checkout new-feature                       # ブランチを切り替える
git branch -d <branchname>                     # ブランチを削除する
git branch -m master master_after              # 別の名前に変更する
git checkout -b alternate master               # ブランチ作成とチェックアウトを同時にする
git checkout -b working                        # 別のブランチで作業してしまい、途中でブランチ作成する場合 Refs: [ブランチを作り忘れた時 # Qiita](http://qiita.com/kkabetani/items/edc69a806095e4fc489c)
git checkout -b new-feature origin/new-feature # リモートのブランチをcheckoutする
git checkout --ours hoge.txt                   # マージでコンフリクトした際にマージ先を優先する場合:
git checkout --theirs hoge.txt                 # マージでコンフリクトした際にマージ元を優先する場合:

# merge - マージする
git checkout master; git merge alternate                                 # 直接マージ(定番)
git checkout master; git merge --squash alternate; git commit -m "reson" # 圧縮コミット(squash)
git merge alternate; git mergetool; git commit                           # 競合を解消する
git merge --no-commit; git merge --abort                                 # conflictするか確かめるだけ

# log - コミットログを見る
git log --stat           # 変更のあったファイル名を表示する
git log --oneline        # 一行で表示
git log --pretty=oneline # ちょっと↑と表示は違う。
git log --committer=hoge # 特定のコミッターのログを見る
git log <revision>       # 特定のリビジョンから始まるログを見る
git log -p               # パッチ形式のコミットログを表示する
git log -S hoge          # 過去のコミットから対象文字列を含むコミットを検索
git log -Shoge           # 過去のコミットから対象文字列を含むコミットを検索
git log --grep hoge      # Git logでコミットメッセージを検索する方法(コミットログでフィルタリング)
git log --grep hoge -p   # Git logでコミットメッセージを検索する方法(コミットログでフィルタリング)
git log -- ./foo ./bar   # 特定のパス(ファイル、ディレクトリ)の履歴を見る
git log -- .             # 特定のパス(ファイル、ディレクトリ)の履歴を見る
git log -- *.xml         # 特定のパス(ファイル、ディレクトリ)の履歴を見る

# show - コミットログと変更点を確認
git show HEAD
git show REVESION_HASH:FILE_PATH # 特定のリビジョンのファイルを見たい

# blame - 誰のコミットか確認する
git blame -L 12,13 somefile # 行番号を指定

# revert - コミットを取り消す(訂正をコミットする)
git revert -n HEAD; git revert -n <rev>; git commit # 複数取り消し、まとめてコミットする

# reset - 変更をリセットする
git reset --soft           # 以前のコミットをすべてステージングエリアに戻す(i.e. 直前のコミットを取り消したい(コミットのみ取り消し)
git reset --hard HEAD^     # 直前のコミットを取り消したい(マルっと消したい)
git reset --hard HEAD      # コミット後の変更を全部消したい
git reset --hard ORIG_HEAD # リセットを取り消したい Refs: [\[git reset (--hard/--soft)\]ワーキングツリー、インデックス、HEADを使いこなす方法 # Qiita](http://qiita.com/shuntaro_tamura/items/db1aef9cf9d78db50ffe)

# rebase - 履歴を書き換える

## pick - コミットの順番を変える
git rebase -i HEAD~3
pick xx..
pick yy..
pick zz..
-> change
pick zz..
pick xx..
pick yy..
保存して終了

## squash - コミットを圧縮
git rebase -i HEAD~3
pick xx..
pick yy..
pick zz..
-> change
pick xx..
squash yy..
pick zz..
保存して終了(xxとyyが圧縮)

## edit - コミット内容を変更する
git rebase -i HEAD^^
// 対象をedit
// 変更内容をadd
git commit --amend
git rebase --continue

Refs: [Git ふたつ以上前のコミットにはcommit--amend できないの-Qiita](http://qiita.com/YumaInaura/items/4f00367fc1a140b61bc7)

## reword - コミットメッセージを変える
git rebase -i HEAD~3
reword xx..

## 元に戻す(rebase直後の場合のみ!)
git reset --hard ORIG_HEAD

## 自動fix(--autofixup)を使う
git commit --fixup=HEAD~1 # 既存コミットを指定する
git rebase -i --autosquash HEAD~4

# stash - 作業を隠す
git stash -u # 未追跡(untracked)ファイルも対象にする

# clean - 追跡対象外ファイルの削除
git clean -n # 確認
git clean -f # 削除
git clean -d # ディレクトリも対象

# remote
git remote    # リモートリポジトリ一覧を確認
git remote -v # リモートリポジトリ一覧を確認

# clone - クローンする
git clone git@github.com:assout/dotfiles.git hoge # ディレクトリを指定する
git clone -b foo_branch git@github.com:assout/dotfiles.git # ブランチを指定する

# fetch - 取得する
git fetch --all # すべてのリモートを取得
git fetch --prune # ブランチの削除情報も取得

# push - 更新する
git push -f                 # 強制
git push --force-with-lease # 強制(最後に fetch したタイミング以降に他人が push していたら失敗する)

# vim:set filetype=sh:

